#!/usr/bin/env python
# Copyright (c) 2014 Spotify AB
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import argparse
import getpass
import json
import logging
import requests
import sys
import urlparse

USER = getpass.getuser()
DEFAULT_CAUSE = "manual spreaper run"

log_level = logging.WARN
if "-v" in sys.argv or "--verbose" in sys.argv:
    log_level = logging.DEBUG
logging.basicConfig(level=log_level, format='%(asctime)s %(name)s %(levelname)s - %(message)s')

log = logging.getLogger("spreaper")
log.debug("logging initialized, the user running this: {0}".format(USER))


# === ReaperCaller deals with talking to the Reaper =====================================

class ReaperCaller(object):
    """Implements the functionality for calling the Reaper service.
    Keep the CLI specific stuff in ReaperCLI.
    """
    def __init__(self, host_name, host_port, use_ssl):
        self.base_url = "{0}://{1}:{2}".format(use_ssl and 'https' or 'http',
                                               str(host_name), int(host_port))

    def _http_req(self, http_method, the_url, params=None):
        http_method = http_method.upper()
        if params is None:
            params = {}
        log.info("making HTTP %s to %s", http_method, the_url)
        if http_method == 'GET':
            r = requests.get(the_url, params=params)
        elif http_method == 'POST':
            r = requests.post(the_url, params=params)
        else:
            assert False, "invalid HTTP method: {0}".format(http_method)
        log.info("HTTP %s return code %s with content of length %s",
                 http_method, r.status_code, len(str(r.text)))
        r.raise_for_status()
        return r.text

    def get(self, endpoint):
        the_url = urlparse.urljoin(self.base_url, endpoint)
        return self._http_req("GET", the_url)

    def post(self, endpoint, **params):
        the_url = urlparse.urljoin(self.base_url, endpoint)
        return self._http_req("POST", the_url, params)

# === Arguments for commands ============================================================


def _global_arguments(parser, command):
    """Arguments relevant for every CLI command
    """
    group = parser.add_argument_group('global arguments')
    group.add_argument("--reaper-host", default="localhost",
                       help="hostname of the Reaper service [localhost]")
    group.add_argument("--reaper-port", default="8080",
                       help="port of the Reaper service [8080]")
    group.add_argument("--reaper-use-ssl", default=False, action='store_true',
                       help="use https to call Reaper [False]")
    group.add_argument("-v", "--verbose", help="increase output verbosity",
                       action="store_true")
    parser.add_argument(command)


def _arguments_for_status_cluster(parser):
    """Arguments relevant for querying cluster status
    """
    parser.add_argument("cluster_name", help="the cluster name")


def _arguments_for_status_repair(parser):
    """Arguments relevant for querying a repair status
    """
    parser.add_argument("run_id", help="identifier of the run to fetch more info about")


def _arguments_for_add_cluster(parser):
    """Arguments relevant for registering a cluster
    """
    parser.add_argument("seed_host", help="the seed host of the Cassandra cluster to be registered")


def _arguments_for_add_table(parser):
    """Arguments relevant for registering a table
    """
    group = parser.add_argument_group('required arguments')
    group.add_argument("--cluster-name", default=None,
                       help="the name of the target Cassandra cluster")
    group.add_argument("--keyspace", default=None,
                       help="the keyspace in the Cassandra cluster")
    group.add_argument("--table", default=None,
                       help="the table within a keyspace in the Cassandra cluster")


def _arguments_for_repair_and_trigger(parser):
    parser.add_argument("--owner", default=USER,
                        help="name of local user calling the Reaper [\"{0}\"]".format(USER))
    parser.add_argument("--cause", default=DEFAULT_CAUSE,
                        help="cause string used for logging and auditing "
                             "purposes [\"{0}\"]".format(DEFAULT_CAUSE))


def _arguments_for_repair(parser):
    """Arguments relevant for registering a repair and optionally triggering it
    """
    _arguments_for_add_table(parser)
    _arguments_for_repair_and_trigger(parser)
    parser.add_argument("--trigger", action='store_true',
                        help="trigger a repair run right after generating it")


def _arguments_for_trigger(parser):
    """Arguments relevant for triggering a repair
    """
    _arguments_for_repair_and_trigger(parser)
    parser.add_argument("run_id", help="ID of the run to trigger")


def _parse_arguments(command, description, usage=None, extra_arguments=None):
    """Generic argument parsing done by every command
    """
    parser = argparse.ArgumentParser(description=description, usage=usage)
    _global_arguments(parser, command)
    if extra_arguments:
        extra_arguments(parser)
    return parser.parse_args()

# === The actual CLI ========================================================================


REAPER_DESCRIPTION = "spreaper (Spotify Reaper) CLI tool is used to control Reaper service " \
                     "through its REST API"


REAPER_USAGE = REAPER_DESCRIPTION + """
Usage: spreaper [<global_args>] <command> [<command_args>]

<command> can be:
    list-clusters  List registered Cassandra clusters in a Reaper
    status-cluster Show status of a Cassandra cluster
    status-repair  Show status of a repair run
    add-cluster    Register a cluster in Reaper
    add-table      Register a table for a previously added cluster
    repair         Create a repair run, optionally triggering it
    trigger        Start a repair run
    ping           Test connectivity to to the Reaper service
"""


class ReaperCLI(object):
    """Aim of this class is to separate CLI (argparse) specific stuff
       separate from the actual logic of calling Reaper.
    """
    def __init__(self):
        if len(sys.argv) < 2:
            print REAPER_USAGE
            exit(1)
        commands = [arg for arg in sys.argv[1:] if not arg[0].startswith('-')]
        if len(commands) < 1:
            print REAPER_USAGE
            exit(1)
        command = commands[0].replace('-', '_')
        if not hasattr(self, command):
            print 'Unrecognized command: {0}'.format(command)
            print REAPER_USAGE
            exit(1)
        # use dispatch pattern to invoke method with same)
        getattr(self, command)()

    def init_reaper(self, args):
        return ReaperCaller(args.reaper_host, args.reaper_port, args.reaper_use_ssl)

    def ping(self):
        args = _parse_arguments(command="ping",
                                description="Test connectivity to the Reaper service")
        reaper = self.init_reaper(args)
        reaper.get("ping")
        print "# pong"

    def list_clusters(self):
        args = _parse_arguments(command='list-clusters',
                                description='Lists all registered Cassandra clusters')
        reaper = self.init_reaper(args)
        print "# listing all available clusters in the Reaper"
        cluster_names = json.loads(reaper.get("cluster"))
        if cluster_names:
            print "# found {0} clusters:".format(len(cluster_names))
            for cluster_name in cluster_names:
                print cluster_name
        else:
            print "no clusters found"

    def status_cluster(self):
        args = _parse_arguments(command='status-cluster',
                                description='Show status of a cluster, including the repairs',
                                extra_arguments=_arguments_for_status_cluster)
        reaper = self.init_reaper(args)
        print "# cluster '{0}':".format(args.cluster_name)
        cluster_data = reaper.get("cluster/{0}".format(args.cluster_name))
        print json.dumps(json.loads(cluster_data), indent=2)

    def status_repair(self):
        args = _parse_arguments(command='status-repair',
                                description='Show status of a repair run',
                                extra_arguments=_arguments_for_status_repair)
        reaper = self.init_reaper(args)
        print "# repair run with id {0}".format(args.run_id)
        repair_run = reaper.get("repair_run/{0}".format(args.run_id))
        print json.dumps(json.loads(repair_run), indent=2)

    def add_cluster(self):
        args = _parse_arguments(command='add-cluster',
                                description="Register a cluster in Reaper",
                                extra_arguments=_arguments_for_add_cluster)
        reaper = self.init_reaper(args)
        print "# registering Cassandra cluster with seed host: {0}".format(args.seed_host)
        reaper.post("cluster", seedHost=args.seed_host)
        print "# registration succeeded"

    def add_table(self):
        args = _parse_arguments(command='add-table',
                                description='Register a table for a cluster already in Reaper',
                                extra_arguments=_arguments_for_add_table)
        if not args.table or not args.keyspace or not args.cluster_name:
            print "Please specify all add-table arguments"
            exit(1)
        reaper = self.init_reaper(args)
        print "# adding table '{0}' for keyspace '{1}' in cluster '{2}'".format(args.table,
                                                                                args.keyspace,
                                                                                args.cluster_name)
        reaper.post("table", clusterName=args.cluster_name, keyspace=args.keyspace,
                    table=args.table)
        print "# table successfully added"

    def repair(self):
        args = _parse_arguments(command='repair',
                                description='Initialise a repair, optionally triggering it',
                                extra_arguments=_arguments_for_repair)
        reaper = self.init_reaper(args)
        if not args.table or not args.keyspace or not args.cluster_name:
            print "Please specify all of cluster, keyspace and table names"
            exit(1)
        print "# registering repair run for {0}/{1}/{2}".format(args.cluster_name, args.keyspace,
                                                                args.table)
        reply = reaper.post("repair_run", clusterName=args.cluster_name, keyspace=args.keyspace,
                            table=args.table, owner=args.owner)
        run_id = json.loads(reply)['id']
        print "# run with id={0} created".format(run_id)
        if args.trigger:
            self._trigger_run(reaper, run_id, args)

    def trigger(self):
        args = _parse_arguments(command='trigger',
                                description='trigger a new or paused repair run',
                                extra_arguments=_arguments_for_trigger)
        reaper = self.init_reaper(args)
        self._trigger_run(reaper, args.id, args)

    def _trigger_run(self, reaper, run_id, args):
        print "# triggering run with id: {0}".format(run_id)
        reaper.post("repair_run/{0}".format(run_id), owner=args.owner, cause=args.cause)
        print "# run triggered"


if __name__ == '__main__':
    ReaperCLI()
